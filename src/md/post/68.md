---
layout: ./src/html/post.pug
page_type: "post"
page_datetime: "2015-08-14T01:26:24"
page_id: "68"
page_title: "yargsを使ってタスク自動化ツールのコマンドにオプションを指定する"
page_tag:
  - "Node.js"
page_description: "yargs便利ですわ〜"
---

Grunt や gulp を使っていると、タスクにオプションを渡して処理を切り分けたいっていう欲求が出てくる。そういう時は[yargs](https://www.npmjs.com/package/yargs)を使えば、コマンドにオプションを指定することでそれをタスク側で受け取ることができるようになる。

<code>npm install --save-dev yargs</code>したのち、タスクを書いてる JS ファイル（Gruntfile.js とか gulpfile.js とか）で、

<pre title="JavaScript"><code data-language="javascript">var yargs = require('yargs').argv;</code></pre>

とやって、タスクの実行で

<pre title="command"><code data-language="shell">$ gulp sass --device=pc</code></pre>

とすると、タスクを書いてる JS 内で<code>yargs</code>にキーと値がオブジェクトで格納されるので、

<pre title="JavaScript"><code data-language="javascript">yargs.device  // -> 'pc'</code></pre>

という按配に取得できる。便利。

オプションは複数渡せるし、真偽値にもできる。試しに以下のようなタスクを書いて実行してみる。

<pre title="gulp task"><code data-language="javascript">gulp.task('test', function() {
    console.log(yargs);
});</code></pre>

<pre title="command"><code data-language="shell">$ gulp test --name=oti --male --female=false --'rain bringer' --note='oti is not real name.'</code></pre>

結果はこちら。

<pre title="console"><code data-language="shell">[11:34:21] Using gulpfile ~/develop/mbrs/test-yargs/gulpfile.js
[11:34:21] Starting 'test'...
{ _: [ 'test' ],
  name: 'oti',
  male: true,
  female: 'false',
  'rain bringer': true,
  note: 'oti is not real name.',
  '$0': '/Users/tkg/.nodebrew/current/bin/gulp' }
[11:34:21] Finished 'conslog' after 1.83 ms</code></pre>

<code>yargs</code>に渡されたオブジェクトにいろいろ入る。見づらいので整形。

<pre title="javascript"><code data-language="javascript">{
    _: [ 'test' ],
    name: 'oti',
    male: true,
    female: 'false',
    'rain bringer': true,
    note: 'oti is not real name.',
    '$0': '/Users/tkg/.nodebrew/current/bin/gulp'
}</code></pre>

値を指定せずにつけた<code>--male</code>は<code>true</code>となる。

値を指定すると全て文字列になる。なので、<code>--female=false</code>としてもブーリアンの<code>false</code>にはならず文字列の<code>'false'</code>となる。ここは注意が必要かも。

<code>--'rain bringer'</code>の結果を見るとキーを文字列にすることもできる。

<code>\_</code>にタスク名、<code>'\$0'</code>に gulp の元ファイルのディレクトリも格納されるようだ。面白そう。

オプションの有無で if 文を作れるというだけでもありがたい。

## gulp での具体的な例

もうちょっと具体的な例にすると以下のようなこんな感じ。自分で使ったのが gulp だったので、gulpfile.js のサンプル。

<pre title="gulpfile.js"><code data-language="javascript">'use strict';

// load plugins
var gulp = require('gulp');
var sass = require('gulp-sass');
var autoprefix = require('gulp-autoprefixer');
<mark>var yargs = require('yargs').argv;</mark>

// config
var config = {
    pc: {
        src: './src/pc/',
        dest: './release/pc/',
        browserSupport: ['last 2 versions', 'ie >= 8']
    },
    sp: {
        src: './src/sp/',
        dest: './release/sp/',
        browserSupport: ['last 3 versions', 'android >= 2']
    }
};

// Sass
gulp.task('sass', function() {
    return gulp.src(config[<mark>yargs.device</mark>].src + 'sass/*.scss')
        .pipe(sass({
            outputStyle: 'compressed'
        }))
        .pipe(autoprefix({
            browsers: config[<mark>yargs.device</mark>].browserSupport,
            cascade: false
        })
        .pipe(gulp.dest(config[<mark>yargs.device</mark>].dest + 'css'));
});</code></pre>

で、タスクの実行はこんな感じ。

<pre title="command"><code data-language="shell">$ gulp sass --device=pc</code></pre>

こうすると PC 用の sass ファイルをコンパイルして PC 向けの autoprefixer に通して PC 用のディレクトリに出力できる。SP 用ならオプションを<code>--device=sp</code>とすればよい。

PC/SP 両方を開発してる時って、同じディレクトリ構成にすることが多いと思うんだけど、それなのに source と destination が違うがためにタスクをたくさん書くことになりがち。PC の SP もまとめて処理するようなタスクにするのは watch でつらいしそもそも無駄がある。<code>gulp.task('sass:pc', ...</code>とか<code>gulp.task('sass:sp', ...</code>とかでネームスペースを分けて 2 倍書くのもめんどうくさい。

オプションで指定すれようにすれば、仮にディレクトリ構成が違ってもそれを吸収できる config を作ればいいだけなので gulpfile.js に対するストレスは減る。

ただデメリットも当然あって、タスクによって*オプションをつけるのが前提になる*というのが、これはこれでまたストレスになり得る。どんなキーにどんな値が必要なのかを JS ファイル内にコメントで書いておくとかしないと 1 日で忘れる。

そこで、npm run-script を使う。

## npm run-script でオプション付きのタスクをラップする

npm run-script がなんであるかは他のブログでいろいろ書かれているので割愛。「npm run-script」で検索すれば良い記事がたくさんでてくるのでぜひ見てみてほしい。

今回はオプション指定をラップするタスクを npm run-script で作ればよい。

package.json で

<pre title="package.json"><code data-language="json">"scripts": {
　　"sass:pc" : "gulp sass --device=pc",
　　"sass:sp" : "gulp sass --device=sp"
}</code></pre>

こうして、コマンドラインでの実行は

<pre title="command"><code data-language="shell">$ npm run sass:sp</code></pre>

こう。

結局<code>\*\*\*:sp</code>なのかいと言うことなかれ、npm run-script でラップすることでタイプ数自体も少なくなるし、Grunt なのか gulp なのかを気にする必要もなくなる。<code>"preinstall"</code>や<code>"start"</code>なども整えれば、新規に加わったメンバーには「<code>npm i</code>して<code>npm start</code>でオッケ〜」と伝えればよい。細かくタスクを実行したいなら package.json か Gruntfile.js もしくは gulpfile.js を見てもらえばいいという具合になる。

<hr>

yargs を使って npm run-script の良さがわかった。僕はそんなに Grunt/gulp に消耗してはいないつもりだったのだけど、どうやらちゃんと消耗していたらしい。
